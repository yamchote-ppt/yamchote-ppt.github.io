\chapter{Fundamental of Problem Solving}

เราจะเริ่มบทแรกของหนังสือเล่มนี้ด้วยทักษะที่สำคัญที่สุดไม่ว่าจะในการเรียนคณิตศาสตร์ หรือจะคอมพิวเตอร์ก็ตาม นั่นคือทักษะการแก้ปัญหา (problem solving) เพราะแก่นแท้ของตัววิชาเหล่านี้นั้นคือการนำความรู้ไปใช้ในการแก้ปัญหาต่าง ๆ ไม่ว่าจะปัญหาในตัววิชาเองในรูปแบบปัญหาเชิงการคำนวณ (computational problem) หรือปัญหาในโลกจริง กล่าวคือ ปัญหาคือสิ่งที่เราจะต้องพบเจอเป็นเรื่องปกติในการเรียนวิชานี้

ในบทนี้เราจะเริ่มจากมาดูกันก่อนว่าปัญหาคืออะไร และการแก้ปัญหาคืออะไร เพราะก่อนจะลงมือแก้ปัญหา เราก็ต้องเข้าใจก่อนว่าสิ่งเหล่านี้คืออะไร หลังจากที่เข้าใจเกี่ยวกับสิ่งที่เรียกว่าปัญหาแล้ว เราจะมาต่อกันว่าทักษะหรือแนวคิดอะไรบ้างที่สำคัญในการแก้ปัญหา โดยจะไม่กล่าวถึงรายละเอียดปลีกย่อยของเทคนิคการแก้ปัญหา เพราะในแต่ละรูปแบบปัญหาที่ต่างกัน ก็จะมีรายละเอียดในเรื่องวิธีการแก้ปัญหาหรือเทคนิคการแก้ปัญหาที่แตกต่างกันออกไป เหมือนการทำโจทย์คณิตศาสตร์ที่รูปแบบโจทย์ที่แตกต่างกันก็อาจจะมีเทคนิคที่แตกต่างกัน แต่ว่าสิ่งที่จะทำให้เรารู้ว่าต้องใช้เทคนิคหรือวิธีการอะไรในการแก้ปัญหาที่ต้องการแก้ก็คือประสบการณ์ที่เราจะได้ฝึกกันในแต่ละบท ๆ ต่อจากนี้นั่นเอง

\section{Problem Solving คืออะไร}

ก่อนจะถามว่าการแก้ปัญหาคืออะไร ก็คงไม่เสียเวลาอะไรนักถ้าเราจะมาพูดคุยตกลงกันให้เข้าใจก่อนว่า อะไรคือ\textbf{ปัญหา} ซึ่งถ้าเราเปิดดูความหมายตามราชบัณฑิต คำนี้จะมีความหมายว่า
\begin{center}
	น. ข้อสงสัย, ข้อขัดข้อง, เช่น ทำได้โดยไม่มีปัญหา, คำถาม, ข้อที่ควรถาม, เช่น ตอบปัญหา, ข้อที่ต้องพิจารณาแก้ไข เช่น ปัญหาเฉพาะหน้า ปัญหาทางการเมือง.
\end{center}
ซึ่งบางความหมาย อาจจะรู้สึกว่าปัญหาก็คืออะไรที่รู้สึกว่าไม่ดี เพราะจะทำให้สิ่งต่าง ๆ ดำเนินไปไม่เป็นไปตามที่ควรจะเป็น เช่นข้อขัดข้อง หรือข้อที่ต้องพิจารณาแก้ไข ทว่ายังมีความหมายอีกกลุ่มหนึ่งที่ดูน่าสนใจคือ ข้อสงสัย ข้อควรถาม ที่เรามักพูดกันว่า ``ตอบปัญหา''

ในหนังสือเล่มนี้ (และในคณิตศาสตร์ รวมไปถึงการเขียนโปรแกรมคอมพิวเตอร์) เราจะให้ความหมายของ \textbf{ปัญหา} คือ \textit{โจทย์ที่ถามหรือกล่าวขึ้นมาพื่อต้องการคำตอบโดยอาจจะมีเงื่อนไขบางอย่างหรือไม่มีก็ได้ โดยจะเป็นการกล่าวถึงสถานการณ์ที่มีสิ่งตั้งต้นอะไรสักอย่าง แล้วสุดท้าย(หลังจากผ่านกระบวนการอะไรสักอย่าง)จะได้สิ่งที่ต้องการออกมา}

ตัวอย่างเช่น ``บริษัทจัดสรรแม่บ้านทำความสะอาดตามสั่งแห่งหนึ่งได้รับการจองคิวใช้บริการแม่บ้านเข้ามาจำนวนหนึ่งจากลูกค้าหลายราย โดยที่ลูกค้าแต่ละคนก็มีจำนวนวันที่ต้องการใช้บริการแม่บ้านไม่เหมือนกัน ทางบริษัทเลยอยากรู้ว่าต้องเตรียมแม่บ้านไว้กี่คน'' ซึ่งเราจะพบว่าปัญหานี้เราต้องการรู้ว่าต้องเตรียมแม่บ้านไว้กี่คน โดยเรามีรายการการจองคิวเป็นตัวตั้งของการตอบปัญหานี้

จากตัวอย่างที่กล่าวมา จะเรียกสิ่งตั้งต้น (เช่นรายการการจองคิวที่บริษัทได้รับ) ว่า\textbf{ข้อมูลขาเข้า} (input) และเราจะเรียกสิ่งที่ได้ออกมา (เช่นจำนวนแม่บ้านที่ต้องเตรียมไว้) ว่า\textbf{ข้อมูลขาออก} (output) ดังนั้น เราอาจจะกล่าวได้อีกแบบหนึ่งว่าปัญหาก็คือการมีข้อมูลขาเข้า และข้อมูลขาออกที่ต้องการ และสิ่งที่เราต้องลงแรงหาก็คือ วิธีการที่จะแปลเปลี่ยนข้อมูลขาเข้าดังกล่าวให้ได้ข้อมูลขาออกตามที่ต้องการ ซึ่งเราจะเรียกกระบวนการการหาวิธีการดังกล่าวว่า\textbf{การแก้ปัญหา} (problem solving) และจะเห็นว่าสิ่งสำคัญอันดับแรกสุดไม่ว่าเราจะแก้ปัญหาอะไรก็ตามคือการทำความเข้าใจภาพรวมของโจทย์ (problem statement) ว่าตัวปัญหาคืออะไร และระบุให้ได้ว่าอะไรคือข้อมูลขาเข้า และข้อมูลขาออก โดยถ้าเทียบกับตัวอย่างบริษัทแม่บ้านทำความสะอาดก่อนหน้า จะมีรายละเอียดดังนี้

\begin{itemize}
	\itemsep0em 
	\item \textbf{โจทย์}: หาวิธีการในการคำนวณจำนวนแม่บ้านที่ต้องเตรียมไว้เมื่อได้รับรายการการจองคิวใช้บริการจากลูกค้า
	\item \textbf{ข้อมูลขาเข้า}: รายการการจองคิวใช้บริการ
	\item \textbf{ข้อมูลขาออก}: จำนวนแม่บ้านที่ต้องเตรียมไว้
\end{itemize}

ทั้งนี้ ตัวปัญหาเองก็อาจจะถูกแบ่งกลุ่มออกเป็นประเภทต่าง ๆ ได้หลายประเภท แต่ปัญหาที่เราจะสนใจกันในหนังสือเล่มนี้นั้นจะเป็นปัญหาในกลุ่ม\textbf{ปัญหาเชิงการคำนวณ} (computational problem) หรือหนังสือบางเล่มจะเรียกว่าปัญหาเชิงการประมวลผล ซึ่งคำว่าคำนวณในที่นี่ไม่ได้หมายถึงเพียงแค่การบวก ลบ คูณ หาร หรือการทำโจทย์คณิตศาสตร์ (calculation) แต่ยังรวมไปถึงการวางแผนเชิงกระบวนการ เชิงตรรกะ เชิงเหตุผล หรือรวมไปถึงการคิดเชิงสัญลักษณ์เองก็ด้วย ไม่จำเป็นว่าจะต้องเป็นปัญหาที่เกี่ยวกับตัวเลขเพียงเท่านั้น ซึ่งกระบวนการการแก้ปัญหาเชิงการคำนวณถือว่าเป็นทักษะที่สำคัญที่สุดในการเขียนโปรแกรม รวมไปถึงการศึกษาคณิตศาสตร์ และวิทยาการคอมพิวเตอร์ โดยเราจะได้กล่าวถึงรายละเอียดของกระบวนการดังกล่าวในหัวข้อถัดไป

\section{การแก้ปัญหาเชิงการคำนวณ}

จากหัวข้อที่แล้ว เราอาจกล่าวโดยสรุปได้ว่าปัญหาเชิงการคำนวณก็คือปัญหาที่จะสามารถแก้ได้ด้วยคอมพิวเตอร์โดยการออกแบบอัลกอริทึมที่เหมาะสม และในการแก้ปัญหาเชิงการคำนวณนั้น จะมีทักษะที่สำคัญที่จะช่วยให้เราแก้ปัญหาเชิงการคำนวณได้อย่างมีประสิทธิภาพอยู่ 4 ทักษะได้แก่
\begin{enumerate}
	\itemsep0em 
	\item การแบ่งย่อยปัญหา (decomposition)
	\item การเข้าใจรูปแบบ (pattern recognition)
	\item การคิดเชิงนามธรรม (abstraction)
	\item การออกแบบขั้นตอนวิธี (algorithm design)
\end{enumerate}

\subsection{การแบ่งย่อยปัญหา (decomposition)}
ในการแก้ปัญหาหนึ่งที่เราได้รับมานั้น อาจเป็นการยากถ้าเราจะหาวิธีที่แปลงข้อมูลขาเข้าให้กลายเป็นข้อมูลขาออกได้ภายในขั้นเดียว อาจจะเนื่องมาจากการแก้ปัญหาดังกล่าวต้องการขั้นตอนย่อย ๆ หรือเครื่องมือย่อย ๆ ในการแก้ปัญหานั้น ดังนั้นเราจึงควรย่อยปัญหาใหญ่ที่ซับซ้อนให้ออกเป็นปัญหาย่อย ๆ ที่จะสามารถแก้ได้ง่าย ๆ ไม่ซับซ้อนก่อน

ตัวอย่างเช่นเราอยากจะต่อจิกซอว์สักรูปหนึ่ง คงเป็นการยากถ้าเราจะเทจิกซอว์ทั้งหมดลงมาในแผ่นเดียวแล้วต่อขึ้นมาด้วยการมองภาพทั้งภาพในเวลาเดียวกัน แต่คงจะดีขึ้นถ้าเรารู้ว่าในภาพมีองค์ประกอบย่อย ๆ ที่เห็นความแตกต่างเรื่องสีอย่างชัดเจน เช่นมีบริเวณหนึ่งที่มีแต่สีแดง และมีอีกบริเวณหนึ่งที่มีแต่สีเขียว หรืออีกบริเวณหนึ่งเป็นลายผ้าสีเหลืองลายจุดสีส้ม เราก็เลยจะแบ่งปัญหาการต่อจิกซอว์ทั้งผืนเป็นปัญหาการต่อจิกซอว์กลุ่มย่อย ๆ ที่เป็นสีแดง, ปัญหาการต่อจิกซอว์กลุ่มย่อย ๆ ที่เป็นสีเขียว และ ปัญหาการต่อจิกซอว์กลุ่มย่อย ๆ ที่เป็นสีเหลืองลายจุดสีส้ม ซึ่งจะทำให้เกิดปัญหาที่เล็กลงและอาจจะซับซ้อนน้อยลงเพราะเรากำจัดตัวเลือกจิกซอว์ที่ไม่เกี่ยวข้องกับบริเวณดังกล่าวออกไปได้เยอะ

ขออีกสักตัวอย่างที่ดูเป็นปัญหาเชิงการคิดเลขมากขึ้น เช่นปัญหาการแก้สมการจำนวนเต็ม $x + y + 12z = 30$ โดยที่ $x, y$ และ $z$ เป็นจำนวนเต็มบวกสามจำนวนที่ต่างกัน โดยโจทย์ต้องการว่ามีผลเฉลย $(x,y,z)$ ดังกล่าวทั้งหมดกี่ครูปแบบ ซึ่งแน่นอนว่าถ้าเราไล่ไปเรื่อย ๆ ก็อาจจะเสร็จได้ไม่ได้ยากมาก เพราะเลขเราต้องการผลบอกแค่ 30 ถ้าต้องไล่ 0 ถึง 30 ก็มีอยู่ไม่เกิน $31 \times 31 \times 31 = 29791$ รูปแบบ ซึ่งถ้าให้คอมพิวเตอร์ช่วยรันให้ก็คงใช้เวลาไม่นาน แต่ถ้าใช้คนก็อาจจะเหนื่อยก่อนและมีคิดผิดบ้างได้ แต่เราจะเห็นว่าการเพิ่มขึ้นของค่า $z$ นั้นกลับมีประโยชน์อย่างมาก เพราะเพิ่มขึ้น 1 ค่าในด้านซ้ายจะเพิ่มขึ้นไปถึง 12 ดังนั้นเราจึงอาจจะสังเกตได้ไม่ยากว่าแยกพิจารณาตามค่า $z$ ไปเลยก็ได้ โดยที่ $z = 0,1,2$ (เพราะถ้ามากกว่านี้ ผลบวกจะเกิน 30) กล่าวคือ เราจะแยกปัญหาหลักเราออกเป็นปัญหาย่อย 3 ปํญหาย่อยคือ
\begin{enumerate}
	\itemsep0em 
	\item เมื่อ $z = 0$: แก้สมการ $x + y = 30$
	\item เมื่อ $z = 1$: แก้สมการ $x + y = 18$
	\item เมื่อ $z = 2$: แก้สมการ $x + y = 6$
\end{enumerate}
ซึ่งแต่ละปัญหาย่อย จะสามารถแก้ได้ด้วยการนับง่าย ๆ

ในการแยกปัญหาย่อยนั้น อาจจะได้ปัญหาย่อยมาในรูปแบบที่แยกกันทำ ต่างคนต่างอิสระจากกัน ทำเสร็จแล้วค่อยนำคำตอบของแต่ละปัญหามาผนวกรวมร่างกันให้กลายเป็นปัญหาใหญ่ เช่นตัวอย่างสมการข้างต้นที่เราสามารถแก้ปัญหาไหนก่อนก็ได้ไม่มีผลต่อกัน หรือเราอาจจะได้ปัญหาย่อยที่มาในรูปแบบที่ต้องทำงานต่อเนื่องกันโดยที่เมื่อทำปัญหาย่อยที่ 1 เสร็จให้นำผลของปัญหาย่อยที่ 1 ไปใช้ต่อเป็นข้อมูลขาเข้าของปัญหาย่อยที่ 2 ก็ได้ ทั้งนี้ ไม่มีกฏตายตัวในการตั้งปัญหาย่อย ขึ้นอยู่กับมุมมองต่อปัญหาตรงหน้าของเรา ณ เวลานั้น

อีกตัวอย่างที่อาจจะใกล้ตัวมากขึ้น เช่นเรากำลังจะพัฒนาระบบ web application การจัดการคะแนนนักเรียนในรายวิชา ซึ่งถ้ามองแต่ปัญหาภาพใหญ่ เราอาจจะวางแผนไม่ได้หรือไม่ตรงเป้าหมาย หรือภาษาชาวบ้านจะเรียกว่า คิดอะไรจนฟุ้งมากเกินไป เราจึงต้องเริ่มจากการมาดูกันก่อนว่าระบบของเราควรมีระบบย่อยอะไรบ้าง เช่นต้องมี (1) ส่วนคำนวณเกรดเฉลี่ย (2) ส่วนตรวจสอบเกรด และ (3) ส่วนแสดงผลรายงาน ซึ่งทำให้เราสามารถโฟกัสไปทีละส่วนได้ หรืออาจจะแบ่งงานกันทำคนละส่วนไปพร้อม ๆ กัน และเมื่อแก้ปัญหาเสร็จทุกส่วน เราก็จะสามารถนำมาประกอบเข้าด้วยกันจนเป็นระบบสมบูรณ์ได้

\subsection{การเข้าใจรูปแบบ (pattern recognition)}
อีกทักษะคือการสังเกตรูปแบบของสิ่งที่เกิดขึ้นในปัญหานั้น การเข้าใจรูปแบบหมายถึงความสามารถในการมองเห็นความคล้ายคลึง ความซ้ำ หรือความสัมพันธ์ระหว่างสิ่งต่าง ๆ ในปัญหาที่เรากำลังเผชิญ ซึ่งจะช่วยให้เรามองเห็นแนวทางแก้ไขที่ง่ายขึ้นหรือสามารถนำแนวทางเดิมมาใช้ซ้ำได้กับปัญหาใหม่ที่มีโครงสร้างใกล้เคียงกัน

ลองนึกภาพว่าเรากำลังหัดเล่นหมากรุก ในตอนแรกเราอาจจะเดินหมากไปเรื่อย ๆ ตามสัญชาตญาณ แต่เมื่อเล่นไปหลายตา เราจะเริ่มสังเกตเห็นรูปแบบบางอย่าง เช่น ถ้าเราเคยใช้ม้ากับเรือบีบมุมจนอีกฝ่ายหนีไม่ได้ รูปแบบนั้นอาจจะเกิดซ้ำได้อีกในเกมถัดไป การเข้าใจรูปแบบนี้ทำให้เราสามารถวางแผนล่วงหน้าได้ และลดการคิดซ้ำในสถานการณ์ที่คล้ายกัน — นั่นคือหัวใจของการเข้าใจรูปแบบในเชิงคำนวณ

ในโลกของคณิตศาสตร์ เราเองก็ใช้ทักษะนี้อยู่เสมอ เช่น เมื่อเราเห็นลำดับตัวเลข $2, 4, 6, 8, \ldots$ เราอาจสังเกตได้ทันทีว่าเป็นลำดับเลขคู่อย่างง่าย หรือหากเราเห็น $1, 1, 2, 3, 5, 8, \ldots$ เราก็รู้ว่าเป็นลำดับฟีโบนักชี (Fibonacci sequence) ซึ่งการรู้จักรูปแบบนี้ช่วยให้เราทำนายพฤติกรรมหรือค่าต่อไปได้โดยไม่ต้องเริ่มจากศูนย์ทุกครั้ง นี่เองคือแก่นของการคิดเชิงแบบแผน (pattern thinking)

ในเชิงการเขียนโปรแกรม เรามักเจอปัญหาที่มีรูปแบบซ้ำ เช่น การวนลูป (loop) การตรวจสอบเงื่อนไข (if-else) หรือการคำนวณผลรวมของข้อมูลหลายค่า ปัญหา “หาผลรวมของจำนวนคู่ทั้งหมดในรายการ” และ “หาผลรวมของจำนวนที่หารด้วย 3 ลงตัว” ดูเหมือนต่างกัน แต่จริง ๆ แล้วมีรูปแบบเดียวกันคือ “การวนลูปและตรวจสอบเงื่อนไขก่อนบวกผลรวม” ดังนั้นเราจึงสามารถเขียนโปรแกรมเดียวกันใช้แก้ปัญหาทั้งสองได้ เพียงแค่เปลี่ยนเงื่อนไขภายในเล็กน้อย

เพื่อให้เห็นภาพเชิงคณิตศาสตร์ ลองพิจารณาปัญหาง่าย ๆ ดังนี้:  
“หาจำนวนเต็มบวกที่น้อยกว่า 50 ทั้งหมดที่เป็นผลคูณของ 3 หรือ 5”  
ถ้าเราไล่ไปทีละจำนวนจะยุ่งยากมาก แต่ถ้าเราสังเกตเห็นรูปแบบว่า “ทุกจำนวนที่เป็น 3, 6, 9, 12, …” และ “ทุกจำนวนที่เป็น 5, 10, 15, 20, …” เราก็สามารถหาคำตอบได้โดยการหาลำดับเลขคูณของ 3 และ 5 แล้วนำมารวมกัน โดยไม่ต้องตรวจสอบทีละจำนวน ซึ่งนี่คือการใช้ pattern recognition ช่วยลดภาระการคำนวณอย่างชัดเจน

ทักษะนี้ยังสำคัญอย่างยิ่งในการเรียนคณิตศาสตร์ไม่ต่อเนื่อง (discrete mathematics) เพราะเราจะพบกับรูปแบบในโครงสร้างข้อมูล เช่น กราฟ (graph) ที่มีลักษณะซ้ำกัน หรือรูปแบบของฟังก์ชันบูลีน (boolean function) ที่มีโครงสร้างเหมือนกันบางส่วน การมองเห็นรูปแบบเหล่านี้ทำให้เราสามารถพิสูจน์ทั่วไปได้ง่ายขึ้น เช่น การพิสูจน์โดยอุปนัยทางคณิตศาสตร์ (mathematical induction) ก็ถือเป็นการมองหาความสัมพันธ์ระหว่างรูปแบบในแต่ละขั้นของปัญหานั่นเอง

กล่าวโดยสรุป การเข้าใจรูปแบบคือการฝึก “สายตาเชิงคำนวณ” ให้เห็นสิ่งที่ซ้ำอยู่ในความซับซ้อนของข้อมูล เมื่อเรามองเห็น pattern ได้ดี เราก็สามารถสร้างอัลกอริทึมที่มีประสิทธิภาพและยืดหยุ่น ใช้แก้ปัญหาได้หลากหลายโดยไม่ต้องเริ่มใหม่ทุกครั้ง และนั่นคือสิ่งที่ทำให้นักคณิตศาสตร์และนักคอมพิวเตอร์สามารถสร้างสรรค์สิ่งใหม่ได้จากสิ่งที่มีอยู่เดิม


\subsection{การคิดเชิงนามธรรม (abstraction)}
ในชีวิตประจำวันของเรา เรามักจะต้องจัดการกับข้อมูลหรือสิ่งต่าง ๆ ที่มีรายละเอียดมากมาย เช่น ถ้าเราจะขับรถไปทำงาน เราไม่จำเป็นต้องคิดถึงแรงเสียดทานระหว่างยางกับถนน หรือการระเหยของน้ำมันในถัง เราเพียงแค่คิดถึง “รถ” ในฐานะสิ่งหนึ่งที่เมื่อบิดกุญแจแล้วสามารถพาเราไปถึงจุดหมายได้ ซึ่งในทางหนึ่งนี่ก็คือการ “คิดเชิงนามธรรม” — การละรายละเอียดปลีกย่อยที่ไม่จำเป็นออก แล้วมองภาพรวมของสิ่งที่เราสนใจเท่านั้น

ในทางคอมพิวเตอร์และคณิตศาสตร์ การคิดเชิงนามธรรม (abstraction) หมายถึงการลดความซับซ้อนของปัญหาหรือข้อมูล โดยมองเฉพาะ “คุณลักษณะสำคัญ” ที่จำเป็นต่อการแก้ปัญหานั้น ตัวอย่างเช่น เมื่อเรากำลังออกแบบโปรแกรมจัดการ “บัญชีผู้ใช้” เราไม่จำเป็นต้องรู้ว่าข้อมูลจริงถูกเก็บอยู่ในฐานข้อมูลแบบใด (เช่น SQL หรือ NoSQL) แต่เราสามารถมองว่า “ผู้ใช้” (user) คือวัตถุหนึ่งที่มีคุณสมบัติพื้นฐาน เช่น ชื่อผู้ใช้ รหัสผ่าน และสิทธิ์การใช้งาน การคิดเชิงนามธรรมในกรณีนี้ช่วยให้เราโฟกัสไปที่โครงสร้างและความสัมพันธ์ของข้อมูล มากกว่าการลงรายละเอียดในเชิงเทคนิค

ในแง่ของคณิตศาสตร์ เราก็ใช้การนามธรรมอยู่เสมอ เช่น เมื่อเราศึกษา “จำนวนจริง” เราไม่ได้สนใจว่าจะเขียนเลขนั้นในรูปทศนิยมหรือเศษส่วน แต่เรามองมันในฐานะ “วัตถุเชิงนามธรรม” ที่มีสมบัติพื้นฐาน เช่น การบวก การลบ การคูณ การหาร หรือเมื่อเราศึกษา “กราฟ (graph)” ในคณิตศาสตร์ไม่ต่อเนื่อง เราไม่ได้สนใจว่าจุดยอดเหล่านั้นแทนคน เมือง หรือคอมพิวเตอร์ แต่เรามองเฉพาะ “ความสัมพันธ์” ระหว่างจุดยอดและเส้นเชื่อม เพื่อทำให้เราสามารถวิเคราะห์โครงสร้างเชิงนามธรรมได้โดยไม่ต้องผูกกับบริบทใดบริบทหนึ่ง

เพื่อให้เห็นภาพที่ชัดเจน ลองดูปัญหาต่อไปนี้:  
“เราต้องการออกแบบโปรแกรมคำนวณผลรวมของราคาสินค้าในตะกร้าออนไลน์”  
หากเราเก็บข้อมูลสินค้าในลิสต์ เช่น `[(‘ดินสอ’, 10), (‘ปากกา’, 15), (‘สมุด’, 20)]` เราไม่จำเป็นต้องสนใจว่าราคามาจากแบรนด์ไหนหรือผลิตที่ใด เราสนใจเพียงว่ามันมี “ชื่อ” และ “ราคา” เท่านั้น ดังนั้นเราสามารถเขียนโปรแกรมแบบนามธรรมได้ว่า

\begin{verbatim}
	total = 0
	for item in cart:
	total += item.price
\end{verbatim}

ซึ่งเป็นรูปแบบทั่วไปที่ใช้ได้กับสินค้าทุกประเภท — จะเป็นของกิน ของใช้ หรือบริการ ก็สามารถใช้โครงสร้างเดียวกันได้ทั้งหมด เพราะเรานามธรรม “สินค้า” ให้เหลือเพียงแค่ “สิ่งที่มีราคา”

การคิดเชิงนามธรรมจึงเป็นทักษะที่สำคัญอย่างยิ่งในการแก้ปัญหาทางคณิตศาสตร์และการออกแบบโปรแกรม เพราะมันทำให้เราเห็น “แบบจำลองของปัญหา” (model) ที่สามารถนำกลับมาใช้ซ้ำได้โดยไม่ต้องออกแบบใหม่ทุกครั้ง ทั้งยังเป็นรากฐานของแนวคิดการเขียนโปรแกรมเชิงวัตถุ (object-oriented programming) และการออกแบบระบบเชิงโมดูลาร์ (modular design) อีกด้วย


\subsection{การออกแบบขั้นตอนวิธี (algorithm design)}
เมื่อเรามีการแบ่งปัญหาออกเป็นส่วนย่อย เข้าใจรูปแบบ และนามธรรมสิ่งต่าง ๆ ให้อยู่ในระดับโครงสร้างแล้ว ขั้นตอนสุดท้ายของการแก้ปัญหาทางเชิงคำนวณก็คือการ “ออกแบบขั้นตอนวิธี” หรือที่เราเรียกกันว่า \textit{algorithm design} ซึ่งหมายถึงการกำหนดลำดับขั้นตอนอย่างชัดเจนในการแก้ปัญหาให้ได้ผลลัพธ์ที่ถูกต้อง

ในทางคณิตศาสตร์ เราอาจคุ้นเคยกับการเขียนลำดับของการคิด เช่น “เริ่มจากสมมติว่า..., จากนั้น..., ดังนั้น...” ซึ่งก็ไม่ต่างอะไรกับอัลกอริทึมในคอมพิวเตอร์เลย เพียงแต่ในโลกของการเขียนโปรแกรม เราต้องทำให้ทุกขั้นตอนนั้นสามารถสั่งให้คอมพิวเตอร์ทำงานได้โดยไม่คลุมเครือ ตัวอย่างเช่น ถ้าโจทย์คือ “หาค่ามากที่สุดในลิสต์ของตัวเลข” เราอาจออกแบบขั้นตอนวิธีดังนี้

\begin{enumerate}
	\item กำหนดให้ตัวแปร \texttt{max} เท่ากับค่าตัวแรกของลิสต์
	\item วนลูปตรวจสอบค่าทุกตัวในลิสต์
	\item ถ้าค่าปัจจุบันมากกว่า \texttt{max} ให้แทนที่ค่า \texttt{max} ด้วยค่านั้น
	\item เมื่อจบลูป ค่าของ \texttt{max} จะเป็นค่าที่มากที่สุด
\end{enumerate}

และเราสามารถแปลงขั้นตอนนี้เป็นโค้ดภาษา Python ได้ตรงไปตรงมา
\begin{verbatim}
	def find_max(numbers):
	max_val = numbers[0]
	for n in numbers:
	if n > max_val:
	max_val = n
	return max_val
\end{verbatim}

อัลกอริทึมนี้แม้จะดูเรียบง่าย แต่สะท้อนให้เห็นการคิดเชิงตรรกะและการวางลำดับขั้นตอนอย่างเป็นระบบ ซึ่งเป็นพื้นฐานของทุกกระบวนการคำนวณ — ตั้งแต่การเรียงข้อมูล (sorting) ไปจนถึงการค้นหาเส้นทางสั้นที่สุดในกราฟ (shortest path in a graph)

ในทางคณิตศาสตร์ไม่ต่อเนื่อง การออกแบบอัลกอริทึมมักเชื่อมโยงกับการใช้หลักตรรกศาสตร์เชิงนิรนัย เช่น การพิสูจน์ว่าขั้นตอนดังกล่าว “ถูกต้องทุกกรณี” หรือ “ให้คำตอบที่ดีที่สุด” ตัวอย่างเช่น อัลกอริทึม Dijkstra สำหรับหาเส้นทางที่สั้นที่สุดในกราฟนั้นอาศัยแนวคิดของการเลือกโหนดที่มีระยะทางต่ำที่สุดที่ยังไม่ถูกเยี่ยมชม ซึ่งเป็นการใช้ตรรกะคณิตศาสตร์ควบคู่กับการออกแบบเชิงลำดับ

เพื่อเห็นภาพในชีวิตจริง สมมติว่าเราต้องการ “จัดลำดับการทำงานของเครื่องจักรในโรงงานให้ใช้เวลาน้อยที่สุด” เราอาจเริ่มจากการนามธรรม “งานแต่ละชิ้น” ให้เป็น “ข้อมูล” ที่มีค่าเวลา และ “เครื่องจักร” ให้เป็น “ตัวประมวลผล” จากนั้นจึงออกแบบขั้นตอนวิธี เช่น “เลือกงานที่ใช้เวลาน้อยที่สุดก่อน” (shortest job first) ซึ่งเป็นหนึ่งในอัลกอริทึมที่ใช้ในระบบปฏิบัติการจริง ๆ ของคอมพิวเตอร์

ดังนั้น การออกแบบขั้นตอนวิธีไม่ใช่เพียงการเขียนโค้ดตามลำดับ แต่คือการแปลงความคิดเชิงตรรกะให้กลายเป็น “ภาษาที่เครื่องเข้าใจได้” และยังต้องพิจารณาประสิทธิภาพของมันในแง่เวลาและทรัพยากร เช่น ถ้าอัลกอริทึมหนึ่งทำงานในเวลา $O(n^2)$ แต่อีกอันทำงานในเวลา $O(n \log n)$ เราก็สามารถใช้คณิตศาสตร์ช่วยพิสูจน์ได้ว่าอันหลังมีประสิทธิภาพดีกว่าในกรณีข้อมูลขนาดใหญ่

กล่าวโดยสรุป การออกแบบขั้นตอนวิธีคือจุดเชื่อมระหว่าง “การคิดเชิงคณิตศาสตร์” กับ “การเขียนโปรแกรมเชิงคอมพิวเตอร์” — เป็นศิลปะแห่งการทำให้ความคิดกลายเป็นสิ่งที่คอมพิวเตอร์ทำได้จริง

\section*{บทสรุปและความเชื่อมโยงสู่ Discrete Mathematics}

จากทั้งสี่ทักษะของการแก้ปัญหาเชิงการคำนวณ — \textit{decomposition, pattern recognition, abstraction} และ \textit{algorithm design} — เราจะเห็นภาพเดียวกันคือ การทำให้ปัญหาซับซ้อนกลายเป็นสิ่งที่คิดได้เป็นขั้นเป็นตอน ตรวจสอบได้ และพิสูจน์ได้ นี่เองคือเหตุผลว่าทำไมการเริ่มต้นวิชานี้ด้วย “ทักษะการแก้ปัญหา” จึงสำคัญ เพราะสิ่งที่เราจะเรียนต่อไปใน \textbf{Discrete Mathematics} คือภาษากลางและกรอบคิดทางคณิตศาสตร์ที่รองรับทักษะทั้งสี่ให้แข็งแรงและนำไปใช้ได้จริง

\begin{itemize}
	\item \textbf{Decomposition} เชื่อมโดยตรงกับแนวคิด \textit{โมดูลาร์} และ \textit{การนิยามแบบเกิดซ้ำ} (recursion): เมื่อเราแตกโจทย์เป็นส่วนย่อย เราจะอธิบายส่วนย่อยเหล่านั้นด้วยนิยามและคุณสมบัติที่ชัดเจน ซึ่งในวิชาดิสครีตจะรองรับด้วย \textbf{ตรรกศาสตร์เชิงประพจน์/เชิงภาคนิพจน์} สำหรับระบุเงื่อนไขอย่างเป็นทางการ และใช้ \textbf{อุปนัยทางคณิตศาสตร์} พิสูจน์ความถูกต้องของการประกอบส่วนย่อยกลับเป็นคำตอบทั้งก้อน
	\item \textbf{Pattern Recognition} ทำให้เราเห็นโครงสร้างซ้ำ เช่น ลำดับ ความสัมพันธ์ซ้ำ และรูปแบบบนกราฟ สิ่งเหล่านี้สอดคล้องกับหัวข้อ \textbf{ลำดับและความสัมพันธ์เกิดซ้ำ (recurrences)}, \textbf{การนับแบบจัดวิธี (combinatorics)}, และ \textbf{ทฤษฎีกราฟ} ซึ่งให้ทั้งเครื่องมือคาดคะเนพฤติกรรม (เช่น สูตรปิด) และวิธีวิเคราะห์โครงสร้างที่ซ่อนอยู่ในปัญหา
	\item \textbf{Abstraction} คือหัวใจของดิสครีต: เราแทนโลกจริงด้วย \textbf{เซต ความสัมพันธ์ ฟังก์ชัน กราฟ ต้นไม้ และโครงสร้างเชิงพีชคณิตอย่างง่าย} เพื่อตัดรายละเอียดที่ไม่จำเป็นและเก็บเฉพาะสมบัติสำคัญ การนามธรรมเช่นนี้ทำให้แบบจำลองหนึ่งนำไปใช้ซ้ำในหลายบริบท และเปิดทางให้เราใช้เครื่องมือพิสูจน์เชิงตรรกะได้ตรงไปตรงมา
	\item \textbf{Algorithm Design} ต้องการทั้ง \textit{ความถูกต้อง} และ \textit{ประสิทธิภาพ}: ดิสครีตให้เครื่องมือพิสูจน์ความถูกต้องด้วย \textbf{ตรรกะ, อินวาเรียนต์, อุปนัย} และช่วยวิเคราะห์ประสิทธิภาพด้วย \textbf{การเติบโตของฟังก์ชัน, บิ๊กโอ, การแก้สมการเวียนเกิด (recurrence)} ตลอดจนแบบจำลองข้อมูลเชิงโครงสร้าง (เช่น กราฟ/ทรี) ที่อัลกอริทึมทำงานอยู่บนนั้น
\end{itemize}

กล่าวโดยสรุป \textbf{Discrete Mathematics} ทำหน้าที่เป็น “ไวยากรณ์และกฎหมายของการคิดเชิงคำนวณ”: 
\begin{enumerate}
	\item ให้ \textit{ภาษาอย่างเป็นทางการ} (ตรรกะ สัญลักษณ์ นิยาม) เพื่อระบุปัญหา เงื่อนไข และเป้าหมายให้ไม่คลุมเครือ
	\item ให้ \textit{แบบจำลองเชิงนามธรรม} (เซต ความสัมพันธ์ ฟังก์ชัน กราฟ ต้นไม้) เพื่อยกระดับปัญหาให้อยู่ในโครงสร้างที่วิเคราะห์ได้
	\item ให้ \textit{วิธีพิสูจน์} (อินดักชัน อินวาเรียนต์ การโต้แย้งแบบหักล้าง ฯลฯ) เพื่อรับรองความถูกต้องของวิธีแก้
	\item ให้ \textit{เครื่องมือวิเคราะห์ประสิทธิภาพ} (การนับ บิ๊กโอ รีเคอเรนซ์ ความน่าจะเป็นพื้นฐาน) เพื่อประเมินความคุ้มค่าของอัลกอริทึม
\end{enumerate}

ดังนั้น บทถัดไปของหนังสือนี้จะค่อย ๆ วางรากฐานองค์ประกอบเหล่านั้นอย่างเป็นลำดับ เริ่มจากภาษาตรรกะและวิธีพิสูจน์ ไปสู่เซต ความสัมพันธ์ ฟังก์ชัน การนับ ทฤษฎีกราฟ และการวิเคราะห์อัลกอริทึม เพื่อให้นักศึกษาสามารถ \textit{นิยามปัญหาให้ชัดเจน, สร้างแบบจำลองที่เหมาะสม, ออกแบบวิธีแก้, พิสูจน์ความถูกต้อง, และประเมินประสิทธิภาพ} ได้ครบถ้วน อันเป็นหัวใจของทั้งการเรียนคณิตศาสตร์เชิงไม่ต่อเนื่องและการพัฒนาซอฟต์แวร์เชิงวิทยาการคอมพิวเตอร์อย่างแท้จริง

\newpage
\section{แบบฝึกหัด: การวิเคราะห์ปัญหาเชิงการคำนวณ}

\noindent
\textbf{วัตถุประสงค์ของใบงาน:}  
ให้นักศึกษาได้ฝึกคิดและลงมือแก้ปัญหาจริง โดยใช้ทั้ง 4 ทักษะของการแก้ปัญหาเชิงการคำนวณ ได้แก่  
\textit{(1) การแบ่งย่อยปัญหา (Decomposition)}  
\textit{(2) การเข้าใจรูปแบบ (Pattern Recognition)}  
\textit{(3) การคิดเชิงนามธรรม (Abstraction)} และ  
\textit{(4) การออกแบบขั้นตอนวิธี (Algorithm Design)}  

\vspace{1em}
\hrule
\vspace{1em}

\section*{แบบฝึกหัดที่ 1: ปัญหาการจัดตารางรถรับส่งนักเรียน}

\textbf{สถานการณ์:}  
โรงเรียนแห่งหนึ่งมีบริการรถรับส่งนักเรียน โดยมีนักเรียนทั้งหมด 50 คนที่พักอยู่ในละแวกต่าง ๆ รอบโรงเรียน  
รถแต่ละคันสามารถรับนักเรียนได้ไม่เกิน 10 คนต่อรอบ และโรงเรียนต้องการให้รถแต่ละคันรับส่งนักเรียนที่อยู่ใกล้กันเพื่อลดระยะทางรวมของการเดินทางลงให้มากที่สุด  
โรงเรียนมีข้อมูลที่อยู่ของนักเรียนทุกคนในรูปพิกัด $(x, y)$ โดยโรงเรียนอยู่ที่จุด $(0,0)$

\vspace{1em}
\textbf{จงวิเคราะห์และเขียนแนวทางการแก้ปัญหานี้ โดยอาศัยทั้ง 4 ทักษะต่อไปนี้:}

\subsection*{1. การแบ่งย่อยปัญหา (Decomposition)}
\textit{คำถามชี้นำ:}  
\begin{itemize}
	\item ปัญหานี้สามารถแยกออกเป็นปัญหาย่อยอะไรได้บ้าง?  
	\item แต่ละส่วนต้องแก้ไขอะไร และผลของแต่ละส่วนจะนำมารวมกันอย่างไร?
\end{itemize}


\vspace{6em}

\subsection*{2. การเข้าใจรูปแบบ (Pattern Recognition)}
\textit{คำถามชี้นำ:}  
- จากข้อมูลนักเรียน 50 คน มีรูปแบบหรือความสัมพันธ์อะไรบ้างที่เราสามารถใช้ประโยชน์ได้?  
- มีเงื่อนไขที่ซ้ำ ๆ หรือโครงสร้างที่คล้ายกันในทุกกลุ่มหรือไม่?

\vspace{6em}
\subsection*{3. การคิดเชิงนามธรรม (Abstraction)}
\textit{คำถามชี้นำ:}  
- ถ้าจะนามธรรมปัญหานี้ให้อยู่ในรูปของคณิตศาสตร์หรือคอมพิวเตอร์ จะมองว่าอะไรคือ “วัตถุ (object)” และอะไรคือ “ความสัมพันธ์ (relation)” ?  
- ปัญหานี้คล้ายกับปัญหาทางคณิตศาสตร์ใดที่เคยรู้จัก (เช่น กราฟ, การจัดกลุ่ม, เส้นทางสั้นที่สุด เป็นต้น)?

\vspace{6em}
\subsection*{4. การออกแบบขั้นตอนวิธี (Algorithm Design)}
\textit{คำถามชี้นำ:}  
- หากต้องให้คอมพิวเตอร์ช่วยแก้ปัญหานี้ ควรกำหนดขั้นตอนการทำงานอย่างไร (ลำดับของการคำนวณหรือการตัดสินใจ)?  
- จะใช้แนวคิดทางคณิตศาสตร์หรือโครงสร้างข้อมูลใดในการคำนวณ เช่น การจัดกลุ่ม (clustering) หรือการหาทางสั้นที่สุด (shortest path)?

\vspace{6em}

\newpage
\section*{แบบฝึกหัดที่ 2: ปัญหาการเรียงเหรียญ (Coin Arrangement Problem)}

\textbf{สถานการณ์:}  
ให้เหรียญ 3 ชนิดคือ เหรียญ 1 บาท, 2 บาท, และ 5 บาท อย่างละไม่จำกัดจำนวน  
จงหาจำนวนวิธีทั้งหมดที่สามารถเรียงเหรียญเหล่านี้ให้ได้ผลรวมของมูลค่าเท่ากับ 20 บาท  
โดยลำดับของเหรียญถือว่ามีความสำคัญ (เช่น (5,5,10) และ (10,5,5) ถือเป็นวิธีต่างกัน)

\vspace{1em}
\textbf{ให้นักศึกษาวิเคราะห์ปัญหานี้ โดยใช้แนวทางของ 4 ทักษะการแก้ปัญหาเชิงการคำนวณ:}


\subsection*{1. การแบ่งย่อยปัญหา (Decomposition)}
\textit{คำถามชี้นำ:}  
- สามารถแยกปัญหานี้เป็นกรณีย่อย ๆ ได้อย่างไร?  
- การแบ่งย่อยช่วยให้เราสามารถนิยามฟังก์ชันหรือสมการใดได้บ้าง?

\vspace{6em}


\subsection*{2. การเข้าใจรูปแบบ (Pattern Recognition)}
\textit{คำถามชี้นำ:}  
- เมื่อคำนวณจำนวนวิธีในกรณีเล็ก ๆ เช่น 5 บาท, 10 บาท, 15 บาท เห็นรูปแบบใดเกิดขึ้นบ้าง?  
- รูปแบบนั้นช่วยให้เราคาดเดาสูตรหรือความสัมพันธ์ทั่วไปได้อย่างไร?

\vspace{6em}


\subsection*{3. การคิดเชิงนามธรรม (Abstraction)}
\textit{คำถามชี้นำ:}  
- จะเขียนปัญหานี้ให้อยู่ในรูปของสมการเวียนเกิด (recurrence relation) ได้หรือไม่?  
- ถ้ามองในเชิง combinatorics หรือ discrete structure ปัญหานี้อยู่ในหมวดใด?

\vspace{6em}


\subsection*{4. การออกแบบขั้นตอนวิธี (Algorithm Design)}
\textit{คำถามชี้นำ:}  
- สามารถออกแบบอัลกอริทึมเพื่อคำนวณจำนวนวิธีได้อย่างไร?  
- จะเลือกใช้แนวทางใดระหว่าง recursive กับ dynamic programming เพราะเหตุใด?

\vspace{6em}


\noindent\textbf{คำถามสะท้อนท้ายใบงาน:}
\begin{itemize}
	\item เมื่อเพิ่มเหรียญชนิดใหม่มูลค่า 10 บาท จะต้องปรับสมการเวียนเกิดอย่างไร?  
\end{itemize}

\vspace{6em}



%\section{แบบฝึกหัด: การแก้ปัญหาการจัดตารางรถรับส่งนักเรียน}
%
%\textbf{โจทย์ใหญ่:}  
%โรงเรียนแห่งหนึ่งมีบริการรถรับส่งนักเรียน โดยมีนักเรียนทั้งหมด 50 คนที่พักอยู่ในละแวกต่าง ๆ รอบโรงเรียน รถแต่ละคันสามารถรับนักเรียนได้ไม่เกิน 10 คนต่อรอบ และโรงเรียนต้องการให้รถแต่ละคันรับส่งนักเรียนที่อยู่ใกล้กันเพื่อลดระยะทางรวมของการเดินทางลงให้มากที่สุด  
%\begin{itemize}
%	\item โรงเรียนมีข้อมูลที่อยู่ของนักเรียนทุกคนในรูปแบบพิกัด $(x, y)$
%	\item รถแต่ละคันมีจุดเริ่มต้นและสิ้นสุดคือที่โรงเรียน (พิกัด $(0,0)$)
%	\item ต้องการให้รถทั้งหมดสามารถรับนักเรียนครบทุกคน โดยแต่ละคนอยู่บนรถเพียงคันเดียว
%\end{itemize}
%จงออกแบบแนวทางการแก้ปัญหานี้โดยอาศัยทั้งสี่ทักษะของการแก้ปัญหาเชิงการคำนวณ
%
%\subsection*{1. การแบ่งย่อยปัญหา (Decomposition)}
%เริ่มจากการแยกปัญหาหลักออกเป็นส่วนย่อยที่จัดการได้ง่ายขึ้น  
%ตัวอย่างเช่น
%\begin{enumerate}
%	\item แบ่งนักเรียนออกเป็นกลุ่มย่อย ๆ ตามพื้นที่ที่อยู่ใกล้กัน (เช่น ใช้ระยะทางหรือรหัสไปรษณีย์)
%	\item สำหรับแต่ละกลุ่ม ให้จัดลำดับการรับนักเรียนให้เหมาะสมที่สุดเพื่อลดระยะทาง (อาจใช้แนวคิดคล้ายปัญหาเส้นทางสั้นที่สุด)
%	\item ตรวจสอบว่าทุกคนได้รับการจัดรถครบ และไม่มีคนใดซ้ำในสองคัน
%\end{enumerate}
%เมื่อทำครบทั้งสามส่วน เราก็สามารถรวมผลเข้าด้วยกันให้เป็นแผนการจัดรถสำหรับนักเรียนทั้งหมดได้
%
%\subsection*{2. การเข้าใจรูปแบบ (Pattern Recognition)}
%ในขั้นตอนนี้ให้สังเกตรูปแบบที่เกิดขึ้นจากข้อมูล เช่น  
%\begin{itemize}
%	\item นักเรียนที่อยู่ใกล้กันมักอยู่ในกลุ่มพื้นที่เดียวกัน (รูปแบบของความใกล้เชิงพิกัด)
%	\item เมื่อเพิ่มจำนวนนักเรียนขึ้น ระยะทางรวมของการเดินทางเพิ่มขึ้นตามรูปแบบที่ไม่เชิงเส้น (non-linear)
%	\item เส้นทางที่สั้นที่สุดมักมีลักษณะ “วนกลับโรงเรียน” ซึ่งเป็นรูปแบบซ้ำในทุกคัน
%\end{itemize}
%การสังเกตรูปแบบเหล่านี้จะช่วยให้เราปรับวิธีแก้ เช่น ใช้กฎว่า “ให้รวมกลุ่มตามระยะทางไม่เกิน 3 กิโลเมตร” หรือ “รถแต่ละคันไม่เกิน 10 คน” ซึ่งเป็น pattern เชิงโครงสร้าง
%
%\subsection*{3. การคิดเชิงนามธรรม (Abstraction)}
%จากปัญหาที่เป็นเรื่องรถและนักเรียน เราสามารถนามธรรมมันให้เป็นปัญหาทางคณิตศาสตร์ได้ว่า  
%\begin{itemize}
%	\item นักเรียนแต่ละคนคือ \textbf{โหนด (node)} ในกราฟ  
%	\item เส้นทางระหว่างนักเรียนสองคนคือ \textbf{ขอบ (edge)} ที่มีน้ำหนักเป็นระยะทาง  
%	\item รถแต่ละคันคือ \textbf{เส้นทางย่อย (subtour)} ที่ต้องผ่านโหนดไม่เกิน 10 โหนดและเริ่ม/จบที่โหนดศูนย์กลาง (โรงเรียน)
%\end{itemize}
%ปัญหานี้จึงมีโครงสร้างคล้ายกับ \textbf{Travelling Salesman Problem (TSP)} แบบหลายเส้นทาง (Multiple TSP) ซึ่งเราสามารถใช้แนวคิดจากกราฟและอัลกอริทึมเชิงคณิตศาสตร์มาเป็นแบบจำลองแทนเรื่องรถรับนักเรียนจริง ๆ ได้
%
%\subsection*{4. การออกแบบขั้นตอนวิธี (Algorithm Design)}
%เมื่อได้แบบจำลองแล้ว ให้ออกแบบขั้นตอนวิธีการแก้ เช่น
%\begin{enumerate}
%	\item คำนวณระยะทางระหว่างนักเรียนทุกคู่ สร้างตารางระยะทาง (distance matrix)
%	\item ใช้ขั้นตอนแบ่งกลุ่มนักเรียน เช่น K-means clustering เพื่อสร้างกลุ่มพื้นที่ไม่เกิน 10 คน
%	\item สำหรับแต่ละกลุ่ม ใช้อัลกอริทึมเช่น Nearest Neighbor หรือ Minimum Spanning Tree เพื่อสร้างเส้นทางสั้นที่สุดที่วนกลับโรงเรียน
%	\item รวมผลเส้นทางของทุกกลุ่มเป็นคำตอบสุดท้าย
%\end{enumerate}
%
%ในตอนท้าย ให้นักศึกษาทดลองเขียนโค้ดจำลองขั้นตอนเหล่านี้ด้วยภาษา Python โดยใช้ข้อมูลจำลอง เช่น สุ่มพิกัดนักเรียน $(x, y)$ 50 จุดในระยะไม่เกิน 10 กิโลเมตรจากโรงเรียน แล้วเปรียบเทียบผลระยะทางรวมเมื่อใช้วิธีการแบ่งกลุ่มแตกต่างกัน
%
%\subsection*{คำถามสะท้อนความเข้าใจ}
%\begin{enumerate}
%	\item ในขั้นตอนใดของการแก้ปัญหานี้ที่เรากำลังใช้ “การคิดเชิงนามธรรม” อย่างชัดเจน?
%	\item ถ้าเรามีนักเรียนเพิ่มเป็น 200 คน จะต้องปรับขั้นตอนวิธีอย่างไรเพื่อไม่ให้เวลาคำนวณเพิ่มขึ้นมากเกินไป?
%	\item ส่วนใดของโจทย์ที่สามารถพิสูจน์ได้ด้วยหลักทางคณิตศาสตร์ในวิชา Discrete Mathematics (เช่น การใช้กราฟ หรือการนับแบบจัดวิธี)?
%\end{enumerate}
%
%\newpage
%\section{แบบฝึกหัด: ปัญหาการเรียงเหรียญ}
%
%\textbf{โจทย์ใหญ่:}  
%ให้เหรียญ 3 ชนิดคือ เหรียญ 1 บาท, 2 บาท, และ 5 บาท อย่างละไม่จำกัดจำนวน  
%จงหาจำนวนวิธีทั้งหมดที่สามารถเรียงเหรียญเหล่านี้ให้ได้ผลรวมของมูลค่าเท่ากับ 20 บาท  
%โดยลำดับของเหรียญถือว่ามีความสำคัญ เช่น (5,5,10) และ (10,5,5) ถือเป็นวิธีที่ต่างกัน
%
%---
%
%\subsection*{1. การแบ่งย่อยปัญหา (Decomposition)}
%เริ่มจากการแยกปัญหาใหญ่ “หาจำนวนวิธีการเรียงเหรียญให้ได้มูลค่า 20 บาท” ออกเป็นปัญหาย่อยที่จัดการได้ง่ายขึ้น เช่น
%
%\begin{enumerate}
%	\item พิจารณาเฉพาะกรณีที่เหรียญสุดท้ายเป็นเหรียญ 1 บาท  
%	\item พิจารณาเฉพาะกรณีที่เหรียญสุดท้ายเป็นเหรียญ 2 บาท  
%	\item พิจารณาเฉพาะกรณีที่เหรียญสุดท้ายเป็นเหรียญ 5 บาท  
%\end{enumerate}
%
%แต่ละกรณีจะทำให้เราสามารถนิยามจำนวนวิธีได้ในรูปแบบเวียนเกิด (recurrence) โดยแยกย่อยจากโจทย์เดิม เช่น ถ้าเหรียญสุดท้ายเป็น 1 บาท ปัญหาจะย่อลงเหลือ “จำนวนวิธีเรียงเหรียญให้ได้ 19 บาท” เป็นต้น  
%กล่าวคือ ถ้าเรากำหนดให้ $f(n)$ แทนจำนวนวิธีเรียงเหรียญให้ได้มูลค่ารวม $n$ บาท เราจะได้
%
%\[
%f(n) = f(n-1) + f(n-2) + f(n-5)
%\]
%
%โดยมีเงื่อนไขตั้งต้น $f(0) = 1$ (เพราะมีวิธีเดียวคือไม่ใช้เหรียญเลย) และ $f(n) = 0$ เมื่อ $n < 0$
%
%---
%
%\subsection*{2. การเข้าใจรูปแบบ (Pattern Recognition)}
%หลังจากแยกปัญหาได้แล้ว ให้ลองคำนวณค่า $f(n)$ สำหรับ $n$ เล็ก ๆ เพื่อหาความสัมพันธ์ เช่น  
%
%\[
%\begin{array}{lcl}
%	f(0) &=& 1\\
%	f(1) &=& 1\\
%	f(2) &=& 2\\
%	f(3) &=& 3\\
%	f(4) &=& 5\\
%	f(5) &=& 8
%\end{array}
%\]
%
%เราจะเริ่มเห็นรูปแบบคล้ายกับลำดับฟีโบนักชีที่ขยายด้วยตัวแปร $f(n-5)$ เพิ่มเข้ามา ซึ่งเป็นการสังเกตรูปแบบของ “การบวกย้อนกลับ” (recurrence pattern) ที่จะนำไปสู่การเขียนอัลกอริทึมในขั้นตอนต่อไป
%
%---
%
%\subsection*{3. การคิดเชิงนามธรรม (Abstraction)}
%เราสามารถนามธรรมปัญหานี้ให้อยู่ในรูปของ \textbf{สมการเวียนเกิด (recurrence relation)} หรือมองในเชิง \textbf{ทฤษฎีการนับ (combinatorics)} ว่า  
%ทุกลำดับของเหรียญคือการ “จัดเรียงลำดับของจำนวนเต็ม” ซึ่งผลรวมของลำดับนั้นเท่ากับ 20  
%ดังนั้น ปัญหานี้จึงสามารถมองได้ในหลายระดับ เช่น
%\begin{itemize}
%	\item มุมมองเชิงโครงสร้างลำดับ: $(x_1, x_2, \ldots, x_k)$ โดยแต่ละ $x_i \in \{1,2,5\}$ และ $\sum x_i = 20$
%	\item มุมมองเชิงฟังก์ชันเวียนเกิด: สร้างฟังก์ชัน $f(n)$ ตามความสัมพันธ์ข้างต้น
%	\item มุมมองเชิงการคำนวณ: เขียนโปรแกรมให้คอมพิวเตอร์คำนวณค่า $f(20)$
%\end{itemize}
%
%การนามธรรมเช่นนี้ทำให้เราไม่จำเป็นต้องพิจารณาเหรียญหรือมูลค่าจริง ๆ แต่เพียงแค่โครงสร้างเชิงจำนวนของมัน
%
%---
%
%\subsection*{4. การออกแบบขั้นตอนวิธี (Algorithm Design)}
%เราสามารถออกแบบอัลกอริทึมเพื่อคำนวณ $f(20)$ ได้หลายวิธี ตัวอย่างเช่น
%
%\paragraph{แบบเวียนเกิด (Recursive Algorithm):}
%\begin{verbatim}
%	def count_ways(n):
%	if n == 0: return 1
%	if n < 0: return 0
%	return count_ways(n-1) + count_ways(n-2) + count_ways(n-5)
%\end{verbatim}
%
%\paragraph{แบบบันทึกผลลัพธ์ (Dynamic Programming):}
%\begin{verbatim}
%	f = [0]*(21)
%	f[0] = 1
%	for i in range(1, 21):
%	if i-1 >= 0: f[i] += f[i-1]
%	if i-2 >= 0: f[i] += f[i-2]
%	if i-5 >= 0: f[i] += f[i-5]
%	print(f[20])
%\end{verbatim}
%
%การใช้โปรแกรมนี้จะได้คำตอบคือจำนวนวิธีทั้งหมดที่สามารถเรียงเหรียญได้เท่ากับ 20 บาท (ซึ่งนักศึกษาสามารถลองรันเพื่อหาค่าได้เอง)
%
%---
%
%\subsection*{คำถามสะท้อนความเข้าใจ}
%\begin{enumerate}
%	\item ขั้นตอนใดของการแก้ปัญหานี้ที่ถือว่าเป็น “การแบ่งย่อยปัญหา” อย่างแท้จริง?  
%	\item รูปแบบที่ปรากฏในค่าของ $f(n)$ คล้ายกับลำดับใดในคณิตศาสตร์ที่เคยรู้จักมาก่อน?  
%	\item ถ้าหากเพิ่มเหรียญมูลค่า 10 บาทเข้าไป จะต้องปรับสมการเวียนเกิดอย่างไร?  
%	\item การสร้างฟังก์ชัน $f(n)$ นี้เกี่ยวข้องกับแนวคิดใดในวิชา Discrete Mathematics (เช่น recursion, recurrence, dynamic programming, หรือ combinatorics)?
%\end{enumerate}
%
%\newpage